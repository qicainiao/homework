<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
       //构造函数类式继承 通过改变this的作用环境，使得子类本身具有父类的各种属性。
       function Parent1(){
           this.name="parent1"
           this.say = function() {
              console.log('hello i am '+ this.name +' and i am '+this.age + ' years old');
            }
       }

       function Child1(){
           Parent1.apply(this)
           this.age="1"
       }
       let child1 = new Child1(); 
       child1.say(); //Child1 {name: "parent1", type: "child"}
       

       //借助原型继承
       function Parent2(){
        this.name="Parent2"
        this.play=[1,2,3]
       }

       Parent2.prototype.say= function(){
         console.log('hello i am '+ this.name +' and i am '+this.age + ' years old');
       }
       function Child2(){
           this.age=2;
       }
       Child2.prototype = new Parent2();
       let child2 = new Child2();
       console.log(child2.say())

       //对比 
       //和原型对比起来，构造函数（类）式继承有什么不一样？首先构造函数类式继承的方法都会存在父对象之中，每一次实例
       //都会将function 保存在内存之中，带来性能问题。其次类式继承是不可变的，在运行时 无法添加修改新的方法。这是一种故步自封的
       //死方法。而原型继承是可以通过改变原型链对子类进行修改的。 另外 类式继承不支持多重继承，对于原型继承来说，只需要写好extend对对象进行扩展即可。

       //但是上面的原型继承有个问题，多个子类共用父类的play，一个修改，都会修改
       let child22 = new Child2();
       child22.play.push(4)
       //现在child2和child22的play都是[1,2,3,4]

      //组合继承（就是把上面的两种构造函数类式继承和原型继承结合起来）
      function Parent3(){
        this.name="Parent3"
        this.play=[1,2,3]
       }
       function Child3(){
         Parent3.call(this)
         this.type3='child3'
       }
       Child3.prototype = new Parent3();
       let child3 = new Child3();
       let child33 = new Child3();
       child33.play.push(4)

       //这个时候child33.play [1,2,3,4] child3.play [1,2,3]  解决了上面的问题 避免了属性的公用
       //缺点 每一次实例化父亲的构造函数执行了2次

       //继承的优化1
       function Parent4(){
          this.name="parent4"
          this.play=[1,2,3]
       }

       function Child4 (){
          Parent4.call(this);
          this.type='child4'
       }
       Child4.prototype = Parent4.prototype;  //这样子直接引用 就避免了构造函数多次执行
       let child4 = new Child4();
       let child44 = new Child4();
       child44.play.push(4)
       console.log(child4,child44)    //child44.play [1,2,3,4] child4.play [1,2,3] 
    
       //这个时候 child4 instanceof(Child4)  true   child4 instanceof(Parent4)   true  没办法区分是子类的实例 还是父类的实例
       //child44 与child4 的构造函数constructor都是Parent4  以上都有这个问题
       //原因 prototype里面有个对象是constructor，而子类的prototype就是父类的prototype 显然child44 与child4 的构造函数constructor就是Parent4 

       //组合优化2

      function Parent5(){
          this.name="parent5"
          this.play=[1,2,3]
       }

       function Child5 (){
          Parent5.call(this);
          this.type='child5'
       }
       jicheng(Parent5,Child5)

       function jicheng(Parent,Child){
          const _constructor = Child.prototype.constructor
          Child.prototype = Parent.prototype
          Child.prototype.constructor = _constructor
       }
       const child5 = new Child5();
       console.log(child5)  //child5 instanceof Parent5


       //优化组合6
      function Parent6(){
          this.name="parent6"
          this.play=[1,2,3]
       }

       function Child6 (){
          Parent6.call(this);
          this.type='child6'
       }
       jicheng(Parent6,Child6)

       function jicheng(Parent,Child){
          const _prototype =Object.create(Parent.prototype)  //达到了父类与子类的原型对象的隔离
          _prototype.constructor =Child.prototype.constructor
          Child.prototype = _prototype
       }
       const child6 = new Child6();
       child6 instanceof Parent6


       //使用Object.create()是将对象继承到__proto__属性上  
    </script>
</head>
<body>
    
</body>
</html>