<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
   <script type="text/javascript">


     //一 类式继承

     var father = function() {
        this.age = 52;
        this.say = function() {
          alert('hello i am '+ this.name + ' and i am '+this.age + 'years old');
        }
      }
      
      var child = function() {
        this.name = 'bill';
        father.call(this);
      }
      
      var man = new child();
      man.say();


     //二 原型继承
     function People(name,age){
       this.name= name;
       this.age= age;
     }

     People.prototype.getAge= function(){
       return this.age+1
     }

     function EngLish(name,age,language){
       People.call(this,name,age); //这个时候call只是继承了父类里面的 this.name= name;和 this.age= age;但是父类的prototype并没有继承
       this.language = language;
     }

     //如果想子类的prototype继承父类的prototype，如果

    //EngLish.prototype = People.prototype;
    //那么子类和父类指向的是一个对象。子类的prototype添加方法的的话父类的prototype也跟着变化，就失去了继承的含义

    function inherits (child,parent){
      var _prototype = Object.create(parent.prototype);
      _prototype.constructor = child.prototype.constructor;
      child.prototype = _prototype;
    }
    inherits(EngLish,People);
    EngLish.prototype.getLanguage= function(){
      return this.language
    }


//     对比
// 　　和原型对比起来，构造函数（类）式继承有什么不一样呢？首先，构造函数继承的方法都会存在父对象之中，
//    每一次实例，都会将funciton保存在内存中，这样的做法毫无以为会带来性能上的问题。其次类式继承是不可变的。
//    在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法。
//    而原型继承是可以通过改变原型链接而对子类进行修改的。
//    另外就是类式继承不支持多重继承，而对于原型继承来说，你只需要写好extend对对象进行扩展即可。

    //三 es6继承
     class Parent{
       constructor(name,age){
         this.name= name;
         this.age= age;
       }

       getName(){
         return this.name
       }
     }

     class Child extends Parent{
       constructor(name,age,language){
         super(name,age);
         this.language = language;
       }

       getLanguage(){
         return this.language;
       }
     }

     var child = new Child("lili",20,"english");
     console.log(child.getName());

   </script>
</body>
</html>
